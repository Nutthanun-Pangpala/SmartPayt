const db = require("../db/dbConnection");
const axios = require("axios");
const bwipjs = require('bwip-js');

require("dotenv").config();

const access_token = process.env.LINE_ACCESS_TOKEN;


exports.registerAccount = async (req, res) => {
  try {
    console.log("üîπ ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å Frontend:", req.body);

    const { lineUserId, name, house_id, Phone_No, Email } = req.body;

    if (!house_id || !Phone_No || !Email) {
      console.log("‚ùå ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏Ñ‡∏£‡∏ö:", { house_id, Phone_No, Email });
      return res.status(400).json({ message: "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡πâ‡∏Ñ‡∏£‡∏ö‡∏ñ‡πâ‡∏ß‡∏ô" });
    }

    if (Phone_No.length !== 10) {
      console.log("‚ùå ‡πÄ‡∏ö‡∏≠‡∏£‡πå‡πÇ‡∏ó‡∏£‡∏®‡∏±‡∏û‡∏ó‡πå‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á:", Phone_No);
      return res.status(400).json({ message: "‡πÄ‡∏ö‡∏≠‡∏£‡πå‡πÇ‡∏ó‡∏£‡∏®‡∏±‡∏û‡∏ó‡πå‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏ß 10 ‡∏´‡∏•‡∏±‡∏Å" });
    }

    console.log("üîé ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•...");
    const checkQuery = "SELECT * FROM users WHERE lineUserId = ? OR house_id = ?";
    const [existingUser] = await db.promise().query(checkQuery, [lineUserId, house_id]);

    if (existingUser.length > 0) {
      console.log("‚ùå ‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ã‡πâ‡∏≥‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö:", existingUser);
      return res.status(400).json({ message: "‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏ô‡∏µ‡πâ‡∏ñ‡∏π‡∏Å‡∏•‡∏á‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô‡πÅ‡∏•‡πâ‡∏ß" });
    }

    console.log("üìù ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡∏á‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•...");
    const insertQuery = `
      INSERT INTO users (lineUserId, name, house_id, Phone_No, Email)
      VALUES (?, ?, ?, ?, ?)
    `;
    const [result] = await db.promise().query(insertQuery, [
      lineUserId, name, house_id, Phone_No, Email
    ]);

    if (result.affectedRows === 0) {
      console.log("‚ùå INSERT ‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à");
      return res.status(500).json({ message: "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ" });
    }

    console.log("‚úÖ ‡∏•‡∏á‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!");

    res.status(201).json({
      message: "‡∏•‡∏á‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!",
      userData: { lineUserId, name, house_id, Phone_No, Email },
    });

  } catch (error) {
    console.error("‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î:", error);
    res.status(500).json({ message: "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö", error: error.message });
  }
};

exports.registerAddress = async (req, res) => {
  try {
    const { 
      lineUserId, 
      house_no, 
      village_no, 
      alley, 
      province, 
      district, 
      sub_district, 
      postal_code, 
      address_type
    } = req.body;


    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö
    if (!lineUserId || !house_no || !village_no || !province || !district || !sub_district || !postal_code || !address_type) {
      return res.status(400).json({ message: "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡πâ‡∏Ñ‡∏£‡∏ö‡∏ñ‡πâ‡∏ß‡∏ô" });
    }

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    const [user] = await db.promise().query("SELECT * FROM users WHERE lineUserId = ?", [lineUserId]);

    if (user.length === 0) {
      return res.status(400).json({ message: "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏á‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô‡∏Å‡πà‡∏≠‡∏ô" });
    }

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏ã‡πâ‡∏≥‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    const [existingAddress] = await db.promise().query(
      `SELECT * FROM addresses 
       WHERE lineUserId = ? 
       AND house_no = ? 
       AND alley = ? 
       AND sub_district = ? 
       AND district = ? 
       AND province = ? 
       AND postal_code = ?`,
      [lineUserId, house_no, alley || "", sub_district, district, province, postal_code]
    );

    if (existingAddress.length > 0) {
      return res.status(400).json({ message: "‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏ô‡∏µ‡πâ‡∏ñ‡∏π‡∏Å‡∏•‡∏á‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô‡πÅ‡∏•‡πâ‡∏ß" });
    }

    // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏´‡∏°‡πà‡∏•‡∏á‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
    const insertQuery = `
      INSERT INTO addresses (
    lineUserId, house_no, village_no, alley, province, district, sub_district, postal_code, address_type, 
    address_verified, created_at, updated_at
  ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())
`;
    const [result] = await db.promise().query(insertQuery, [
      lineUserId, house_no, village_no, alley || "", province, district, sub_district, postal_code, address_type, false
    ]);

    if (result.affectedRows === 0) {
      return res.status(500).json({ message: "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡πÑ‡∏î‡πâ" });
    }

    res.status(201).json({
      message: "‡∏•‡∏á‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!",
      addressData: { 
        lineUserId, house_no, village_no, alley, province, district, sub_district, postal_code, address_type, address_verified: false 
      },
    });

  } catch (error) {
    console.error("‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î:", error);
    res.status(500).json({ message: "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö" });
  }
};

exports.userAddressList = async (req, res) => {
  const { page = 1, search = '', sortField = 'id', sortDirection = 'ASC' } = req.query;
  const limit = 10;
  const offset = (page - 1) * limit;

  let searchCondition = 'WHERE 1=1'; // ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ WHERE ‡πÑ‡∏°‡πà Error
  let searchParams = [];

  if (search) {
    searchCondition += `
        AND (c.house_id LIKE ? 
        OR c.Phone_No LIKE ? 
        OR ch.Address LIKE ?)
    `;
    searchParams = [`%${search}%`, `%${search}%`, `%${search}%`];
  }

  const countSql = `
      SELECT COUNT(*) AS total 
      FROM customers c
      LEFT JOIN customer_homes ch ON c.id = ch.customer_id
      ${searchCondition}
  `;

  const sql = `
  SELECT c.id, c.Name, c.house_id, c.Phone_No, ch.Home_ID, ch.Address, ch.village_no  // ‡πÄ‡∏û‡∏¥‡πà‡∏° village_no
  FROM customers c
  LEFT JOIN customer_homes ch ON c.id = ch.customer_id
  ${searchCondition}
  ORDER BY ?? ${sortDirection === 'desc' ? 'DESC' : 'ASC'}
  LIMIT ? OFFSET ?
  `;

  db.query(countSql, searchParams, (err, countResults) => {
      if (err) {
          return res.status(500).json({ message: 'Failed to fetch users', error: err.message });
      }

      const total = countResults[0].total;
      const totalPages = Math.ceil(total / limit);

      db.query(sql, [sortField, ...searchParams, parseInt(limit), parseInt(offset)], (err, results) => {
          if (err) {
              return res.status(500).json({ message: 'Failed to fetch users', error: err.message });
          }

          res.json({
              users: results,
              totalPages,  // üëà ‡∏™‡πà‡∏á totalPages ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ
              currentPage: parseInt(page),
              totalUsers: total
          });
      });
  });
};


exports.reportiIssue = (req, res) => {
  const { Issues, lineUserId, name } = req.body;

  // Check for missing fields
  if (!Issues || !lineUserId || !name) {
    return res.status(400).json({ message: '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡πâ‡∏Ñ‡∏£‡∏ö‡∏ñ‡πâ‡∏ß‡∏ô' });
  }

  const sql = 'INSERT INTO issues (Issues, lineUserId, name) VALUES (?, ?, ?)';
  db.query(sql, [Issues, lineUserId, name], async (err, result) => {
    if (err) {
      console.error('‚ùå Insert Error:', err);
      return res.status(500).json({ message: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•' });
    }

    try {
      await axios.post(
        "https://api.line.me/v2/bot/message/push",
        {
          to: lineUserId,
          messages: [
            {
              type: "text",
              text: `‚úÖ ‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏£‡πâ‡∏≠‡∏á!\nüìå ‡∏ä‡∏∑‡πà‡∏≠: ${name}\nüìå ‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏õ‡∏±‡∏ç‡∏´‡∏≤: ${Issues}`,
            },
          ],
        },
        {
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${access_token}`, // Use your LINE bot access token
          },
        }
      );

      // Respond after sending the message
      res.json({ message: '‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏£‡πâ‡∏≠‡∏á‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!' });
    } catch (lineError) {
      console.error("‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÑ‡∏õ‡∏¢‡∏±‡∏á LINE:", lineError);
      res.status(500).json({ message: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÑ‡∏õ‡∏¢‡∏±‡∏á LINE' });
    }
  });
};

exports.userAddress = async (req, res) => {
  try {
    const { lineUserId } = req.params; // ‡∏î‡∏∂‡∏á lineUserId ‡∏à‡∏≤‡∏Å URL parameters

    if (!lineUserId) {
      return res.status(400).json({ message: "lineUserId ‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÉ‡∏ô‡∏Ñ‡∏≥‡∏Ç‡∏≠" });
    }

    // Query ‡∏î‡∏∂‡∏á‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ
    const query = "SELECT * FROM addresses WHERE lineUserId = ?";
    const [addresses] = await db.promise().query(query, [lineUserId]);

    if (addresses.length === 0) {
      return res.status(404).json({ message: "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà" });
    }

    // ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
    res.status(200).json({
      message: "‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à",
      addresses: addresses, // ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö arrayN
    });

  } catch (error) {
    console.error("‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î:", error);
    res.status(500).json({ message: "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö" });
  }
};


exports.userAddressBill = async (req, res) => {
  try {
    const { address_id } = req.params;

    // ‡∏î‡∏∂‡∏á‡∏ö‡∏¥‡∏•‡∏ó‡∏µ‡πà‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏ä‡∏≥‡∏£‡∏∞ (0) ‡πÅ‡∏•‡∏∞‡∏£‡∏≠‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö (2)
    const query = "SELECT * FROM bills WHERE address_id = ? AND status IN (0, 2)";
    const [bills] = await db.promise().query(query, [address_id]);

    if (bills.length === 0) {
      return res.status(200).json({ bills: [] }); // ‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤‡∏ö‡∏¥‡∏•‡πÄ‡∏õ‡πá‡∏ô array ‡∏ß‡πà‡∏≤‡∏á
    }

    res.status(200).json({ bills });
  } catch (error) {
    console.error("‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ö‡∏¥‡∏•:", error);
    res.status(500).json({ message: "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö" });
  }
};

exports.generateBarcode = (req, res) => {
  const { addressId } = req.params;

  bwipjs.toBuffer({
    bcid: 'code128',        // Barcode type
    text: addressId,        // Text to encode in the barcode
    scale: 3,               // Barcode scale
    height: 10,             // Barcode height
  })
  .then((buffer) => {
    // Set headers for image response
    res.setHeader('Content-Type', 'image/png');
    res.send(buffer);  // Send the generated barcode buffer as an image
  })
  .catch((error) => {
    console.error("Error generating barcode:", error);
    res.status(500).json({ message: 'Error generating barcode', error: error.message });
  });
};

exports.updateAccount = async (req, res) => {
  try {
    const lineUserId = req.params.lineUserId || req.body.lineUserId;
    const { name, ID_card_No, Phone_No, Email } = req.body;

    if (!lineUserId) {
      return res.status(400).json({ message: 'lineUserId is required' });
    }

    await db.promise().query(
      'UPDATE users SET name = ?, ID_card_No = ?, Phone_No = ?, Email = ? WHERE lineUserId = ?',
      [name, ID_card_No, Phone_No, Email, lineUserId]
    );

    res.json({ message: 'Account updated successfully' });
  } catch (err) {
    console.error(err);
    res.status(500).json({ message: 'Server Error' });
  }
};

exports.getPaymentHistory = async (req, res) => {
    const { lineUserId } = req.params;
  
    try {
      const [rows] = await db.promise().query(
        `SELECT bills.*
         FROM bills
         JOIN addresses ON bills.address_id = addresses.address_id
         WHERE addresses.lineUserId = ? AND bills.status = 1
         ORDER BY bills.due_date DESC`,
        [lineUserId]
      );
  
      res.json(rows);
    } catch (error) {
      console.error(error);
      res.status(500).json({ message: "Server error" });
    }
  };

  // controllers/userWaste.controller.js

// controller
exports.getWasteSummary = async (req, res) => {
  try {
    const { address_id, from, to } = req.query;
    const lineUserId = req.params.lineUserId || req.query.lineUserId;

    if (!lineUserId && !address_id) {
      return res.status(400).json({ message: '‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏∞‡∏ö‡∏∏ lineUserId ‡∏´‡∏£‡∏∑‡∏≠ address_id' });
    }

    const now = new Date();
    const startDefault = new Date(now.getFullYear(), now.getMonth(), 1).toISOString().slice(0,10);
    const endDefault   = new Date(now.getFullYear(), now.getMonth()+1, 1).toISOString().slice(0,10);
    const start = (from && /^\d{4}-\d{2}-\d{2}$/.test(from)) ? from : startDefault;
    const end   = (to   && /^\d{4}-\d{2}-\d{2}$/.test(to))   ? to   : endDefault;

    // ‚úÖ ‡πÉ‡∏ä‡πâ db.promise().query ‡πÅ‡∏ó‡∏ô pool
    let addressIds = [];
    if (address_id) {
      addressIds = [address_id];
    } else {
      const [rows] = await db.promise().query(
        `SELECT address_id FROM addresses WHERE lineUserId = ?`,
        [lineUserId]
      );
      if (!rows.length) {
        return res.json({
          range: { from: start, to: end },
          addresses: [],
          overall: {},
          byAddress: {},
          daily: [],
          dailyByAddress: {}
        });
      }
      addressIds = rows.map(r => r.address_id);
    }

    const placeholders = addressIds.map(() => '?').join(',');
    const params = [...addressIds, start, end];

    const [sumOverall] = await db.promise().query(
      `SELECT wr.waste_type, SUM(wr.weight_kg) AS total_kg
         FROM waste_records wr
        WHERE wr.address_id IN (${placeholders})
          AND wr.recorded_date >= ?
          AND wr.recorded_date <  ?
        GROUP BY wr.waste_type`,
      params
    );

    const [sumByAddr] = await db.promise().query(
      `SELECT wr.address_id, wr.waste_type, SUM(wr.weight_kg) AS total_kg
         FROM waste_records wr
        WHERE wr.address_id IN (${placeholders})
          AND wr.recorded_date >= ?
          AND wr.recorded_date <  ?
        GROUP BY wr.address_id, wr.waste_type`,
      params
    );

    const [dailyOverall] = await db.promise().query(
      `SELECT DATE(wr.recorded_date) AS day, wr.waste_type, SUM(wr.weight_kg) AS total_kg
         FROM waste_records wr
        WHERE wr.address_id IN (${placeholders})
          AND wr.recorded_date >= ?
          AND wr.recorded_date <  ?
        GROUP BY DATE(wr.recorded_date), wr.waste_type
        ORDER BY DATE(wr.recorded_date)`,
      params
    );

    const [dailyByAddrRows] = await db.promise().query(
      `SELECT wr.address_id, DATE(wr.recorded_date) AS day, wr.waste_type, SUM(wr.weight_kg) AS total_kg
         FROM waste_records wr
        WHERE wr.address_id IN (${placeholders})
          AND wr.recorded_date >= ?
          AND wr.recorded_date <  ?
        GROUP BY wr.address_id, DATE(wr.recorded_date), wr.waste_type
        ORDER BY DATE(wr.recorded_date)`,
      params
    );

    const typeTH = { general:'‡∏Ç‡∏¢‡∏∞‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ', hazardous:'‡∏Ç‡∏¢‡∏∞‡∏≠‡∏±‡∏ô‡∏ï‡∏£‡∏≤‡∏¢', recyclable:'‡∏Ç‡∏¢‡∏∞‡∏£‡∏µ‡πÑ‡∏ã‡πÄ‡∏Ñ‡∏¥‡∏•', organic:'‡∏Ç‡∏¢‡∏∞‡∏≠‡∏¥‡∏ô‡∏ó‡∏£‡∏µ‡∏¢‡πå' };

    const overall = {};
    sumOverall.forEach(r => { overall[typeTH[r.waste_type] || r.waste_type] = Number(r.total_kg); });

    const byAddress = {};
    sumByAddr.forEach(r => {
      if (!byAddress[r.address_id]) byAddress[r.address_id] = { '‡∏Ç‡∏¢‡∏∞‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ':0,'‡∏Ç‡∏¢‡∏∞‡∏≠‡∏±‡∏ô‡∏ï‡∏£‡∏≤‡∏¢':0,'‡∏Ç‡∏¢‡∏∞‡∏£‡∏µ‡πÑ‡∏ã‡πÄ‡∏Ñ‡∏¥‡∏•':0,'‡∏Ç‡∏¢‡∏∞‡∏≠‡∏¥‡∏ô‡∏ó‡∏£‡∏µ‡∏¢‡πå':0 };
      byAddress[r.address_id][typeTH[r.waste_type] || r.waste_type] = Number(r.total_kg);
    });

    const dailyMap = {};
    dailyOverall.forEach(r => {
      const d = (r.day instanceof Date) ? r.day.toISOString().slice(0,10) : r.day;
      if (!dailyMap[d]) dailyMap[d] = { day: d, '‡∏Ç‡∏¢‡∏∞‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ':0,'‡∏Ç‡∏¢‡∏∞‡∏≠‡∏±‡∏ô‡∏ï‡∏£‡∏≤‡∏¢':0,'‡∏Ç‡∏¢‡∏∞‡∏£‡∏µ‡πÑ‡∏ã‡πÄ‡∏Ñ‡∏¥‡∏•':0,'‡∏Ç‡∏¢‡∏∞‡∏≠‡∏¥‡∏ô‡∏ó‡∏£‡∏µ‡∏¢‡πå':0 };
      dailyMap[d][typeTH[r.waste_type] || r.waste_type] = Number(r.total_kg);
    });

    const dailyByAddress = {};
    const tmp = {};
    dailyByAddrRows.forEach(r => {
      const d = (r.day instanceof Date) ? r.day.toISOString().slice(0,10) : r.day;
      if (!tmp[r.address_id]) tmp[r.address_id] = {};
      if (!tmp[r.address_id][d]) tmp[r.address_id][d] = { day: d, '‡∏Ç‡∏¢‡∏∞‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ':0,'‡∏Ç‡∏¢‡∏∞‡∏≠‡∏±‡∏ô‡∏ï‡∏£‡∏≤‡∏¢':0,'‡∏Ç‡∏¢‡∏∞‡∏£‡∏µ‡πÑ‡∏ã‡πÄ‡∏Ñ‡∏¥‡∏•':0,'‡∏Ç‡∏¢‡∏∞‡∏≠‡∏¥‡∏ô‡∏ó‡∏£‡∏µ‡∏¢‡πå':0 };
      tmp[r.address_id][d][typeTH[r.waste_type] || r.waste_type] = Number(r.total_kg);
    });
    Object.keys(tmp).forEach(addr => { dailyByAddress[addr] = Object.values(tmp[addr]); });

    return res.json({
      range: { from: start, to: end },
      addresses: addressIds,
      overall,
      byAddress,
      daily: Object.values(dailyMap),
      dailyByAddress
    });
  } catch (err) {
    console.error('getWasteSummary error:', err);
    return res.status(500).json({ message: '‡∏î‡∏∂‡∏á‡∏™‡∏£‡∏∏‡∏õ‡∏Ç‡∏¢‡∏∞‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à', error: err.message });
  }
};